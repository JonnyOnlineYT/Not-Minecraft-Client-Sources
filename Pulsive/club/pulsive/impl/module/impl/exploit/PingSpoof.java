package club.pulsive.impl.module.impl.exploit;

import club.pulsive.api.event.eventBus.handler.EventHandler;
import club.pulsive.api.event.eventBus.handler.Listener;
import club.pulsive.api.main.Pulsive;
import club.pulsive.impl.event.network.PacketEvent;
import club.pulsive.impl.event.player.PlayerMotionEvent;
import club.pulsive.impl.event.player.WorldLoadEvent;
import club.pulsive.impl.module.Category;
import club.pulsive.impl.module.Module;
import club.pulsive.impl.module.ModuleInfo;
import club.pulsive.impl.module.impl.combat.Aura;
import club.pulsive.impl.module.impl.movement.Flight;
import club.pulsive.impl.module.impl.player.Scaffold;
import club.pulsive.impl.property.implementations.DoubleProperty;
import club.pulsive.impl.property.implementations.EnumProperty;
import club.pulsive.impl.util.client.Logger;
import club.pulsive.impl.util.client.TimerUtil;
import club.pulsive.impl.util.math.MathUtil;
import club.pulsive.impl.util.network.PacketUtil;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import org.lwjgl.input.Keyboard;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

@ModuleInfo(name = "Ping Spoof", renderName = "Ping Spoof", category = Category.EXPLOIT, keybind = Keyboard.KEY_NONE)

public class PingSpoof extends Module {
    private final ConcurrentLinkedQueue<Packet> concurrentLinkedQueue = new ConcurrentLinkedQueue<>();
    private final ConcurrentLinkedQueue<Packet> concurrentLinkedQueue2 = new ConcurrentLinkedQueue<>();
    private final TimerUtil timerUtil = new TimerUtil();
    private final Deque<Packet> packetQueue = new ArrayDeque<>();
    private final TimerUtil timer1 = new TimerUtil();
    private boolean booleanThing;
    private final List<IgnoredPosition> ignoredPositionList = new CopyOnWriteArrayList<>();
    private final EnumProperty<MODES> mode = new EnumProperty<>("Mode", MODES.WATCHDOG);
    private final DoubleProperty spikeInterval = new DoubleProperty("Spike Interval", 10000, 5000, 20000, 500, () -> mode.getValue() == MODES.WATCHDOG);
    private final DoubleProperty spikeAmount = new DoubleProperty("Spike Amount", 200, 150, 500, 50, () -> mode.getValue() == MODES.WATCHDOG);
    public static final TimerUtil spikeStopwatch = new TimerUtil();
    public static int stage = 0;

    @Override
    public void init() {
        this.addValueChangeListener(this.mode);
        super.init();
    }

    @EventHandler
    private final Listener<PlayerMotionEvent> playerMotionEventListener = event ->{
        if(mode.getValue() == MODES.WATCHDOG) {
            if (!event.isPre() || !mc.getNetHandler().doneLoadingTerrain)
                return;
            // reset stage
            if (stage == 0) {
                if (spikeStopwatch.hasElapsed(MathUtil.randomInt(500, 1000))) {
                    while (!packetQueue.isEmpty())
                        PacketUtil.sendPacketNoEvent(packetQueue.remove());
                   // Logger.logNew("PRe Flushed");
                    spikeStopwatch.reset();
                }
            }
            if (stage == 1 && spikeStopwatch.hasElapsed(spikeInterval.getValue().intValue()) && !Pulsive.INSTANCE.getModuleManager().getModule(Flight.class).isToggled()
                    && !Pulsive.INSTANCE.getModuleManager().getModule(Scaffold.class).isToggled()
                    && Pulsive.INSTANCE.getModuleManager().getModule(Aura.class).getTarget() == null) {
                spikeStopwatch.reset();
                stage = 2;
                Logger.print("Spiking...");
            }
        }
    };


    @Override
    public void onEnable() {
        timer1.reset();
        concurrentLinkedQueue.clear();
        concurrentLinkedQueue2.clear();
        ignoredPositionList.clear();
        packetQueue.clear();
        timerUtil.reset();
        stage = 0;
        booleanThing = false;
        super.onEnable();
    }

    @EventHandler
    private final Listener<PacketEvent> packetEventListener = event -> {
        switch (event.getEventState()) {
            case SENDING:
                switch (mode.getValue()) {
                    case WATCHDOG: {
                        if(event.getPacket() == null || !mc.getNetHandler().doneLoadingTerrain) return;
                        if (event.getPacket() instanceof C03PacketPlayer) {
                            final C03PacketPlayer packetPlayer = event.getPacket();
                            if (!packetPlayer.isMoving()) {
                                event.setCancelled(true);
                                return;
                            }
                            if (packetPlayer instanceof C03PacketPlayer.C05PacketPlayerLook) {
                                event.setCancelled(true);
                                return;
                            }
                            if (packetPlayer instanceof C03PacketPlayer.C06PacketPlayerPosLook) {
                                //event.setPacket(new C03PacketPlayer.C04PacketPlayerPosition(packetPlayer.getPositionX(), packetPlayer.getPositionY(), packetPlayer.getPositionZ(), packetPlayer.isOnGround()));
                            }
                        }
                        switch (stage) {
                            case 0:
                                event.setCancelled(true);
                                packetQueue.add(event.getPacket());
                                break;
                            case 1:
                                while (!packetQueue.isEmpty())
                                    PacketUtil.sendPacketNoEvent(packetQueue.remove());
                                // idk yet
                                break;
                            case 2:
                                if (Pulsive.INSTANCE.getModuleManager().getModule(Flight.class).isToggled()) {
                                    spikeStopwatch.reset();
                                    return;
                                }
                                if (event.getPacket() instanceof C03PacketPlayer || event.getPacket() instanceof C00PacketKeepAlive || event.getPacket() instanceof C0FPacketConfirmTransaction) {
                                    packetQueue.add(event.getPacket());
                                    event.setCancelled(true);
                                }
                                if (spikeStopwatch.hasElapsed(spikeAmount.getValue().intValue())) {
                                    while (!packetQueue.isEmpty())
                                        PacketUtil.sendPacketNoEvent(packetQueue.remove());
                                    spikeStopwatch.reset();
                                    Logger.print("Flushed");
                                    stage = 1;
                                }
                                break;
                        }
                        break;
                    }
                    case DEFAULT: {
                        if (event.getPacket() instanceof C0FPacketConfirmTransaction) {
                            if (event.getPacket() instanceof C0FPacketConfirmTransaction) {
                                concurrentLinkedQueue.add(event.getPacket());
                                event.setCancelled(true);
                            }
                        }
                        if (event.getPacket() instanceof C00PacketKeepAlive) {
                            concurrentLinkedQueue.add(event.getPacket());
                            event.setCancelled(true);
                        }
                        if (timer1.hasElapsed(1490)) {
                            concurrentLinkedQueue.forEach(PacketUtil::sendPacketNoEvent);
                            concurrentLinkedQueue.clear();
                            timer1.reset();

                        }
                        if (concurrentLinkedQueue2.size() >= 2) {
                            concurrentLinkedQueue2.forEach(PacketUtil::sendPacketNoEvent);
                            concurrentLinkedQueue2.clear();

                        }
                        break;
                    }
                    case DIRECTCANCELLATION: {
                        if (event.getPacket() instanceof C0FPacketConfirmTransaction || event.getPacket() instanceof C00PacketKeepAlive) {
                            event.setCancelled(true);
                        }
                        break;
                    }
                }
                break;
            case RECEIVING:{
                if(mode.getValue() == MODES.WATCHDOG){
                    if (event.getPacket() instanceof S08PacketPlayerPosLook && !Pulsive.INSTANCE.getModuleManager().getModule(Flight.class).isToggled() && mc.thePlayer.ticksExisted > 10) {
                        final S08PacketPlayerPosLook packetIn = event.getPacket();
                        final EntityPlayer entityplayer = mc.thePlayer;
                        double d0 = packetIn.getX();
                        double d1 = packetIn.getY();
                        double d2 = packetIn.getZ();

                        if (packetIn.func_179834_f().contains(S08PacketPlayerPosLook.EnumFlags.X)) {
                            d0 += entityplayer.posX;
                        } else {
                            entityplayer.motionX = 0.0D;
                        }

                        if (packetIn.func_179834_f().contains(S08PacketPlayerPosLook.EnumFlags.Y)) {
                            d1 += entityplayer.posY;
                        } else {
                            entityplayer.motionY = 0.0D;
                        }

                        if (packetIn.func_179834_f().contains(S08PacketPlayerPosLook.EnumFlags.Z)) {
                            d2 += entityplayer.posZ;
                        } else {
                            entityplayer.motionZ = 0.0D;
                        }
                        entityplayer.setPosition(d0, d1, d2);
                        mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(entityplayer.posX, entityplayer.getEntityBoundingBox().minY, entityplayer.posZ, false));

                        if (!mc.getNetHandler().doneLoadingTerrain) {
                            entityplayer.prevPosX = entityplayer.posX;
                            entityplayer.prevPosY = entityplayer.posY;
                            entityplayer.prevPosZ = entityplayer.posZ;
                            mc.getNetHandler().doneLoadingTerrain = true;
                            mc.displayGuiScreen(null);
                        }
                        event.setCancelled(true);
                    }
                    else if (event.getPacket() instanceof S32PacketConfirmTransaction && stage == 0) {
                        final S32PacketConfirmTransaction packetConfirmTransaction = event.getPacket();
                        if (packetConfirmTransaction.getWindowId() == 0 && packetConfirmTransaction.getActionNumber() < 0) {
                            Logger.print("Watchdog disabled! " + packetConfirmTransaction.getWindowId() + " " + packetConfirmTransaction.getActionNumber());
                            stage = 1;
                        }
                    }
                }
                break;
            }
        }
    };

    @EventHandler
    private final Listener<WorldLoadEvent> worldLoadEventListener = event -> {
        timer1.reset();
        concurrentLinkedQueue.clear();
        concurrentLinkedQueue2.clear();
        timerUtil.reset();
        stage = 0;
        booleanThing = false;
        packetQueue.clear();
    };

    @AllArgsConstructor
    private enum MODES {
        WATCHDOG("Watchdog"),
        DEFAULT("Default"),
        DIRECTCANCELLATION("Direct Cancellation");

        private final String modeName;

        @Override
        public String toString() {return modeName;}
    }

    @Getter
    @Setter
    @AllArgsConstructor
    private static final class IgnoredPosition {
        private final double x, y, z;
    }
}
