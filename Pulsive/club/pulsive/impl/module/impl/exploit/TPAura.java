package club.pulsive.impl.module.impl.exploit;

import club.pulsive.api.event.eventBus.handler.EventHandler;
import club.pulsive.api.event.eventBus.handler.Listener;
import club.pulsive.api.main.Pulsive;
import club.pulsive.impl.event.player.AttackEvent;
import club.pulsive.impl.event.player.PlayerMotionEvent;
import club.pulsive.impl.event.render.Render3DEvent2;
import club.pulsive.impl.module.Category;
import club.pulsive.impl.module.Module;
import club.pulsive.impl.module.ModuleInfo;
import club.pulsive.impl.module.impl.combat.pathfinder.MainPathFinder;
import club.pulsive.impl.module.impl.combat.pathfinder.Vec3;
import club.pulsive.impl.module.impl.visual.HUD;
import club.pulsive.impl.property.Property;
import club.pulsive.impl.property.implementations.DoubleProperty;
import club.pulsive.impl.property.implementations.EnumProperty;
import club.pulsive.impl.property.implementations.MultiSelectEnumProperty;
import club.pulsive.impl.util.client.TimerUtil;
import club.pulsive.impl.util.entity.EntityValidator;
import club.pulsive.impl.util.entity.impl.AliveCheck;
import club.pulsive.impl.util.entity.impl.ConstantDistanceCheck;
import club.pulsive.impl.util.entity.impl.EntityCheck;
import club.pulsive.impl.util.entity.impl.TeamsCheck;
import club.pulsive.impl.util.math.apache.ApacheMath;
import club.pulsive.impl.util.network.PacketUtil;
import club.pulsive.impl.util.player.PlayerUtil;
import club.pulsive.impl.util.render.RenderUtil;
import com.google.common.collect.Lists;
import lombok.AllArgsConstructor;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;

import java.awt.*;
import java.util.*;
import java.util.List;

@ModuleInfo(name = "TpAura", category = Category.COMBAT)
public class TPAura extends Module {
    private final EnumProperty<Mode> mode = new EnumProperty<Mode>("Mode", Mode.SINGLE);
    private final DoubleProperty cps = new DoubleProperty("CPS", 5, 1, 20, 1);
    private final DoubleProperty range = new DoubleProperty("Range", 20, 4, 120, 1);
    private final DoubleProperty timerSpeed = new DoubleProperty("Timer", 1, 0.1, 3, 0.1);
    private final DoubleProperty maxTargets = new DoubleProperty("Max Targets", 25, 2, 50, 1);
    private final MultiSelectEnumProperty<PlayerUtil.TARGETS> targetsProperty = new MultiSelectEnumProperty<>("Targets", Lists.newArrayList(PlayerUtil.TARGETS.PLAYERS), PlayerUtil.TARGETS.values());
    private final Property<Boolean> render = new Property<>("Render", true);
    private EntityValidator entityValidator = new EntityValidator();
    private final List<EntityLivingBase> targets = new ArrayList<>();
    private TimerUtil timer = new TimerUtil();
    private EntityLivingBase target;
    private ArrayList<Vec3> path = new ArrayList<>();

    @EventHandler
    private final Listener<PlayerMotionEvent> playerMotionEventListener = event -> {
        if(event.isPre()){
            if (!timer.hasElapsed((long) (((20 - cps.getValue()) * 50) - ApacheMath.random() * 100))) return;
            entityValidator = new EntityValidator();
            final AliveCheck aliveCheck = new AliveCheck();
            final EntityCheck entityCheck = new EntityCheck(targetsProperty.isSelected(PlayerUtil.TARGETS.PLAYERS), targetsProperty.isSelected(PlayerUtil.TARGETS.ANIMALS), targetsProperty.isSelected(PlayerUtil.TARGETS.MOBS), targetsProperty.isSelected(PlayerUtil.TARGETS.INVISIBLE));
            final TeamsCheck teamsCheck = new TeamsCheck(targetsProperty.isSelected(PlayerUtil.TARGETS.TEAMS));
            entityValidator.add(aliveCheck);
            entityValidator.add(new ConstantDistanceCheck(range.getValue().floatValue()));
            entityValidator.add(entityCheck);
            entityValidator.add(teamsCheck);
            updateTargets();
            targets.sort(new DistanceSorter());

            if(mode.getValue() == Mode.MULTI && targets.size() > maxTargets.getValue())
                targets.subList(maxTargets.getValue().intValue(), targets.size()).clear();


            timer.reset();
            if(targets.isEmpty()) return;
            target = getTarget();

            final EntityPlayer player = mc.thePlayer;
            double x = player.posX;
            double y = player.posY;
            double z = player.posZ;

            final double targetX = target.posX;
            final double targetY = target.posY;
            final double targetZ = target.posZ;

            mc.timer.timerSpeed = timerSpeed.getValue().floatValue();

            final double finalZ = z;
            final double finalY = y;
            final double finalX = x;
            new Thread(() -> {
                switch(mode.getValue()){
                    case SINGLE:{
                        path = MainPathFinder.computePath(new Vec3(finalX, finalY, finalZ), new Vec3(targetX, targetY, targetZ));

                        for (final Vec3 vec : path)
                            PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.getX(), vec.getY(), vec.getZ(), false));

                        mc.thePlayer.swingItem();
                        final AttackEvent attackEvent = new AttackEvent(target);
                        Pulsive.INSTANCE.getEventBus().call(attackEvent);

                        if (!attackEvent.isCancelled())
                            PacketUtil.sendPacketNoEvent(new C02PacketUseEntity(target, C02PacketUseEntity.Action.ATTACK));

                        Collections.reverse(path);

                        for (final Vec3 vec : path)
                            PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.getX(), vec.getY(), vec.getZ(), false));
                        break;
                    }
                    case MULTI:{
                        for (final Entity entity : targets) {
                            /* Getting path */
                            path = MainPathFinder.computePath(new Vec3(finalX, finalY, finalZ), new Vec3(entity.posX, entity.posY, entity.posZ));

                            for (final Vec3 vec : path)
                                PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.getX(), vec.getY(), vec.getZ(), true));

                            mc.thePlayer.swingItem();

                            /*
                             * Calls attack event so other modules can use information from the entity
                             * When the C02 packet is sent the attack event does not
                             * get called, so we have to manually call it ourselves in here.
                             */
                            final AttackEvent attackEvent = new AttackEvent(entity);
                            Pulsive.INSTANCE.getEventBus().call(attackEvent);

                            if (!attackEvent.isCancelled())
                                PacketUtil.sendPacketNoEvent(new C02PacketUseEntity(entity, C02PacketUseEntity.Action.ATTACK));

                            Collections.reverse(path);

                            for (final Vec3 vec : path)
                                PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.getX(), vec.getY(), vec.getZ(), true));
                        }
                        break;
                    }
                }
            }).start();
        }
    };

    @EventHandler
    private final Listener<Render3DEvent2> render3DEvent2Listener = event -> {
        if (!render.getValue() || path == null || target == null) return;

        Vec3 lastPoint = null;

        final Color c = new Color(HUD.getColor()).brighter();

        for (final Vec3 point : path) {
            if (lastPoint != null) {
                RenderUtil.draw3DLine(lastPoint.getX(), lastPoint.getY() + 0.01, lastPoint.getZ(), point.getX(), point.getY() + 0.01, point.getZ(), c.getRed(), c.getGreen(), c.getBlue(), 255, 1);
            }
            lastPoint = point;
        }
    };

    public final EntityLivingBase getTarget() {
        if (targets.isEmpty()) {
            return null;
        }

        return targets.get(0);
    }

    private final static class DistanceSorter implements Comparator<EntityLivingBase> {
        public int compare(EntityLivingBase o1, EntityLivingBase o2) {
            return Double.compare(mc.thePlayer.getDistanceToEntity(o1), mc.thePlayer.getDistanceToEntity(o2));
        }
    }

    @Override
    public void onDisable() {
        super.onDisable();
        target = null;
        targets.clear();
    }

    private void updateTargets() {
        targets.clear();

        final List<Entity> entities = mc.theWorld.loadedEntityList;

        for (int i = 0, entitiesSize = entities.size(); i < entitiesSize; i++) {
            final Entity entity = entities.get(i);
            if (entity instanceof EntityLivingBase) {
                final EntityLivingBase entityLivingBase = (EntityLivingBase) entity;
                if (entityValidator.validate(entityLivingBase)) {
                    this.targets.add(entityLivingBase);
                }
            }
        }
    }

    @AllArgsConstructor
    public enum Mode{
        SINGLE("Single"),
        MULTI("Multi");

        private final String modeName;

        @Override
        public String toString() {return modeName;}
    }


}
