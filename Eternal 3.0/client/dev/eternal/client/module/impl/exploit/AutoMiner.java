package dev.eternal.client.module.impl.exploit;

import dev.eternal.client.event.Subscribe;;
import dev.eternal.client.event.events.EventPacket;
import dev.eternal.client.event.events.EventRender3D;
import dev.eternal.client.event.events.EventUpdate;
import dev.eternal.client.module.Module;
import dev.eternal.client.module.api.ModuleInfo;
import dev.eternal.client.util.pathfinder.Node;
import dev.eternal.client.util.pathfinder.PathInfo;
import dev.eternal.client.util.pathfinder.Pather;
import dev.eternal.client.util.render.RenderUtil;
import dev.eternal.client.util.world.WorldUtil;
import net.minecraft.block.BlockCrops;
import net.minecraft.block.BlockPotato;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemSeeds;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.Vec3;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@ModuleInfo(name = "autominer", description = "bruh", category = Module.Category.EXPLOIT)
public class AutoMiner extends Module {

  private BlockPos target;
  private boolean processed, completedOperation;
  private PathInfo currentPath;
  private final List<PathInfo> pathList = new CopyOnWriteArrayList<>();
  private final List<BlockPos> blockList = new CopyOnWriteArrayList<>();

  public AutoMiner() {
    if (isEnabled()) toggle();
  }

  @Override
  public void onEnable() {
    blockList.clear();
    processed = completedOperation = false;
    new Thread(
        () -> {
          searchForpotato();
          processed = true;
        })
        .start();
  }

  @Subscribe
  public void onUpdate(EventUpdate eventUpdate) {
    if (eventUpdate.pre()) {
      for (int i = 0; i < 9; i++) {
        final ItemStack stackInHotBar = mc.thePlayer.inventory.getStackInSlot(i);
        if (stackInHotBar == null) continue;
        final Item item = stackInHotBar.getItem();

        if (item == Items.potato)
          mc.thePlayer.inventory.currentItem = i;
      }
      if (!processed) return;
      if (!completedOperation) {
        breakpotatoes();
      } else {
        replaceCrops();
      }
    }
  }

  @Subscribe
  public void render3D(EventRender3D eventRender3D) {
    if (currentPath == null) return;
    RenderUtil.pre3D();
    GlStateManager.disableTexture2D();
    GlStateManager.translate(
        -RenderManager.renderPosX, -RenderManager.renderPosY, -RenderManager.renderPosZ);
    for (PathInfo pathInfo : pathList) {
      GL11.glLineWidth(5);
      GL11.glColor4f(0.0F, 0.0F, 0.0F, 1.0F);
      GL11.glBegin(GL11.GL_LINE_STRIP);
      for (Node node : pathInfo.pathList()) {
        final BlockPos bp = node.blockPos();
        GL11.glVertex3d(bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5);
      }
      GL11.glEnd();

      GL11.glLineWidth(3);
      GL11.glBegin(3);
      for (Node node : pathInfo.pathList()) {
        final BlockPos bp = node.blockPos();
//        Colors.setGLColour(ColorUtil.getClientColour(0, 0.8F, 1));
        GL11.glVertex3d(bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5);
      }
      GL11.glEnd();
    }
    RenderUtil.post3D();
  }

  @Subscribe
  public void onPacket(EventPacket eventPacket) {
//        if (eventPacket.getPacket() instanceof S08PacketPlayerPosLook) {
//            toggle();
//            toggle();
//        }
  }

  private void breakBlock(BlockPos blockPos) {
    mc.thePlayer.sendQueue.addToSendQueue(
        new C07PacketPlayerDigging(
            C07PacketPlayerDigging.Action.START_DESTROY_BLOCK, blockPos, EnumFacing.NORTH));
    mc.thePlayer.sendQueue.addToSendQueue(new C07PacketPlayerDigging(
        C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, blockPos, EnumFacing.NORTH));
  }

  private void replaceCrops() {
    if (blockList.isEmpty()) {
      toggle();
      toggle();
      return;
    }
    target = blockList.get(0);

    if (WorldUtil.isAir(target)) {
      blockList.remove(target);
      target = null;
      return;
    }

    pathList.clear();

    currentPath = Pather.getPath(target.add(0, 1, 0));

    pathList.add(currentPath);

    List<Node> xd = new ArrayList<>();
    int itr = 0;
    for (Node node : currentPath.pathList()) {
      if ((itr % 5 != 0
          || mc.theWorld.getBlockState(node.blockPos()).getBlock() != Blocks.air) && itr != currentPath.pathList().size() - 1)
        xd.add(node);
      itr++;
    }
    currentPath.pathList().removeAll(xd);

    for (Node node : currentPath.pathList()) {
      final BlockPos bp = node.blockPos();
      mc.thePlayer.sendQueue.addToSendQueue(
          new C03PacketPlayer.C04PacketPlayerPosition(
              bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5, true));
    }

    mc.thePlayer.swingItem();
    mc.playerController.onPlayerRightClick(mc.thePlayer, mc.theWorld, mc.thePlayer.getHeldItem(), target, EnumFacing.UP, new Vec3(0, 0, 0));

    Collections.reverse(currentPath.pathList());

    for (Node node : currentPath.pathList()) {
      final BlockPos bp = node.blockPos();
      mc.thePlayer.sendQueue.addToSendQueue(
          new C03PacketPlayer.C04PacketPlayerPosition(
              bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5, true));
    }

    blockList.remove(target);
    target = null;
  }

  private void breakpotatoes() {
    completedOperation = blockList.isEmpty();
    if (completedOperation) {
      searchForEmptyFarmLand();
      return;
    }
    target = blockList.get(0);

    if (WorldUtil.isAir(target)) {
      blockList.remove(target);
      target = null;
      return;
    }

    pathList.clear();

    currentPath = Pather.getPath(target.add(0, 1, 0));

    pathList.add(currentPath);

    //      if (currentPath.getPathList().size() == 0) return;

    List<Node> xd = new ArrayList<>();
    int itr = 0;
    for (Node node : currentPath.pathList()) {
      if ((itr % 5 != 0
          || mc.theWorld.getBlockState(node.blockPos()).getBlock() != Blocks.air) && itr != currentPath.pathList().size() - 1)
        xd.add(node);
      itr++;
    }
    currentPath.pathList().removeAll(xd);

    for (Node node : currentPath.pathList()) {
      final BlockPos bp = node.blockPos();
      mc.thePlayer.sendQueue.addToSendQueue(
          new C03PacketPlayer.C04PacketPlayerPosition(
              bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5, true));
    }

    mc.thePlayer.swingItem();
    breakBlock(target);
    mc.playerController.onPlayerRightClick(mc.thePlayer, mc.theWorld, mc.thePlayer.getHeldItem(), target, EnumFacing.UP, new Vec3(0, 0, 0));

    Collections.reverse(currentPath.pathList());

    for (Node node : currentPath.pathList()) {
      final BlockPos bp = node.blockPos();
      mc.thePlayer.sendQueue.addToSendQueue(
          new C03PacketPlayer.C04PacketPlayerPosition(
              bp.getX() + 0.5, bp.getY(), bp.getZ() + 0.5, true));
    }

    blockList.remove(target);
    target = null;
  }

  private void searchForEmptyFarmLand() {
    for (int i = (int) mc.thePlayer.posY; i > mc.thePlayer.posY - 3; i--) {
      for (int j = (int) mc.thePlayer.posX - 50; j < mc.thePlayer.posX + 50; j++) {
        for (int k = (int) mc.thePlayer.posZ - 50; k < mc.thePlayer.posZ + 50; k++) {
          blockList.add(new BlockPos(j, i, k));
        }
      }
    }
    blockList.removeIf(blockPos ->
        mc.theWorld.getBlockState(blockPos).getBlock() != Blocks.farmland ||
            !WorldUtil.isAir(blockPos.add(0, 1, 0))
    );
  }

  private void searchForpotato() {
    for (int i = (int) mc.thePlayer.posY; i > mc.thePlayer.posY - 2; i--) {
      for (int j = (int) mc.thePlayer.posX - 50; j < mc.thePlayer.posX + 50; j++) {
        for (int k = (int) mc.thePlayer.posZ - 50; k < mc.thePlayer.posZ + 50; k++) {
          blockList.add(new BlockPos(j, i, k));
        }
      }
    }
    blockList.removeIf(blockPos ->
        mc.theWorld.getBlockState(blockPos).getBlock() != Blocks.potatoes
    );
    blockList.removeIf(blockPos ->
        mc.theWorld.getBlockState(blockPos).getValue(BlockCrops.AGE) < 7);
  }
}
